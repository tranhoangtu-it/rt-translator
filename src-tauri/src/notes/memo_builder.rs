use crate::providers::{ChatMessage, LlmProvider, OllamaProvider};
use std::sync::Arc;

use super::note_types::IncrementalNotesResponse;

/// Builds meeting memos from accumulated notes.
pub struct MemoBuilder {
    provider: Arc<OllamaProvider>,
}

impl MemoBuilder {
    pub fn new(provider: Arc<OllamaProvider>) -> Self {
        Self { provider }
    }

    /// Generate meeting memo markdown from accumulated notes.
    /// Calls Ollama to generate executive summary, then formats as markdown.
    pub async fn generate_memo(
        &self,
        meeting_title: &str,
        meeting_date: &str,
        notes: &IncrementalNotesResponse,
    ) -> anyhow::Result<String> {
        if notes.is_empty() {
            return Ok(self.generate_empty_memo(meeting_title, meeting_date));
        }

        // Generate executive summary via LLM
        let executive_summary = self.generate_executive_summary(notes).await?;

        // Format as markdown
        Ok(self.format_memo_markdown(
            meeting_title,
            meeting_date,
            &executive_summary,
            notes,
        ))
    }

    /// Generate executive summary from notes using Ollama.
    async fn generate_executive_summary(
        &self,
        notes: &IncrementalNotesResponse,
    ) -> anyhow::Result<String> {
        let notes_json = serde_json::to_string_pretty(notes)?;

        let messages = vec![
            ChatMessage {
                role: "system".to_string(),
                content: "You are an executive assistant. Write concise 2-3 sentence meeting summaries highlighting key outcomes.".to_string(),
            },
            ChatMessage {
                role: "user".to_string(),
                content: format!(
                    "Summarize this meeting in 2-3 sentences:\n\n{}",
                    notes_json
                ),
            },
        ];

        let summary = self.provider.chat(messages).await?;
        Ok(summary.trim().to_string())
    }

    /// Format meeting memo as markdown.
    fn format_memo_markdown(
        &self,
        meeting_title: &str,
        meeting_date: &str,
        executive_summary: &str,
        notes: &IncrementalNotesResponse,
    ) -> String {
        let mut md = String::new();

        // Header
        md.push_str(&format!("# {}\n\n", meeting_title));
        md.push_str(&format!("**Date:** {}\n\n", meeting_date));

        // Executive Summary
        md.push_str("## Executive Summary\n\n");
        md.push_str(executive_summary);
        md.push_str("\n\n");

        // Key Points
        if !notes.key_points.is_empty() {
            md.push_str("## Key Points\n\n");
            for kp in &notes.key_points {
                md.push_str(&format!(
                    "- **{}** [{}]: {}\n",
                    kp.topic, kp.timestamp, kp.summary
                ));
            }
            md.push_str("\n");
        }

        // Decisions
        if !notes.decisions.is_empty() {
            md.push_str("## Decisions Made\n\n");
            for dec in &notes.decisions {
                md.push_str(&format!("- [{}] {}\n", dec.timestamp, dec.decision));
                if let Some(rationale) = &dec.rationale {
                    md.push_str(&format!("  - *Rationale:* {}\n", rationale));
                }
            }
            md.push_str("\n");
        }

        // Action Items
        if !notes.action_items.is_empty() {
            md.push_str("## Action Items\n\n");
            for action in &notes.action_items {
                let mut item = format!("- {}", action.task);
                if let Some(owner) = &action.owner {
                    item.push_str(&format!(" (*Owner:* {})", owner));
                }
                if let Some(deadline) = &action.deadline {
                    item.push_str(&format!(" (*Deadline:* {})", deadline));
                }
                if let Some(priority) = &action.priority {
                    item.push_str(&format!(" [Priority: {}]", priority));
                }
                md.push_str(&format!("{}\n", item));
            }
            md.push_str("\n");
        }

        // Risks
        if !notes.risks.is_empty() {
            md.push_str("## Risks & Concerns\n\n");
            for risk in &notes.risks {
                md.push_str(&format!("- [{}] {}\n", risk.timestamp, risk.risk));
                if let Some(impact) = &risk.impact {
                    md.push_str(&format!("  - *Impact:* {}\n", impact));
                }
                if let Some(mitigation) = &risk.mitigation {
                    md.push_str(&format!("  - *Mitigation:* {}\n", mitigation));
                }
            }
            md.push_str("\n");
        }

        md.push_str("\n---\n");
        md.push_str("*Generated by RT Translator*\n");

        md
    }

    fn generate_empty_memo(&self, meeting_title: &str, meeting_date: &str) -> String {
        format!(
            "# {}\n\n**Date:** {}\n\n## Executive Summary\n\nNo notes were captured during this meeting.\n\n---\n*Generated by RT Translator*\n",
            meeting_title, meeting_date
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::notes::note_types::*;

    #[test]
    fn creates_memo_builder() {
        let provider = Arc::new(OllamaProvider::default());
        let _builder = MemoBuilder::new(provider);
    }

    #[test]
    fn formats_empty_memo() {
        let provider = Arc::new(OllamaProvider::default());
        let builder = MemoBuilder::new(provider);
        let memo = builder.generate_empty_memo("Test Meeting", "2026-02-10");
        assert!(memo.contains("Test Meeting"));
        assert!(memo.contains("2026-02-10"));
        assert!(memo.contains("No notes were captured"));
    }

    #[test]
    fn formats_memo_with_notes() {
        let provider = Arc::new(OllamaProvider::default());
        let builder = MemoBuilder::new(provider);

        let notes = IncrementalNotesResponse {
            key_points: vec![KeyPoint {
                topic: "Test Topic".to_string(),
                summary: "Test summary".to_string(),
                timestamp: "00:01:00".to_string(),
            }],
            decisions: vec![Decision {
                decision: "Test decision".to_string(),
                rationale: Some("Test rationale".to_string()),
                timestamp: "00:02:00".to_string(),
            }],
            action_items: vec![ActionItem {
                task: "Test task".to_string(),
                owner: Some("John".to_string()),
                deadline: Some("Friday".to_string()),
                priority: Some("high".to_string()),
            }],
            risks: vec![Risk {
                risk: "Test risk".to_string(),
                impact: Some("High".to_string()),
                mitigation: Some("Test mitigation".to_string()),
                timestamp: "00:03:00".to_string(),
            }],
        };

        let memo = builder.format_memo_markdown(
            "Test Meeting",
            "2026-02-10",
            "This is a test summary.",
            &notes,
        );

        assert!(memo.contains("Test Meeting"));
        assert!(memo.contains("2026-02-10"));
        assert!(memo.contains("Executive Summary"));
        assert!(memo.contains("This is a test summary"));
        assert!(memo.contains("Key Points"));
        assert!(memo.contains("Test Topic"));
        assert!(memo.contains("Decisions Made"));
        assert!(memo.contains("Test decision"));
        assert!(memo.contains("Action Items"));
        assert!(memo.contains("Test task"));
        assert!(memo.contains("Risks & Concerns"));
        assert!(memo.contains("Test risk"));
    }
}
